<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:sf="antlib:com.salesforce" default="Build" basedir=".">
	
	<include file="cumulusci.xml" />
	
	<target name="Build">
		<echo>Continuous Integration Build</echo>
		<taskdef resource="net/sf/antcontrib/antlib.xml" />
		<property environment="env" />
		<echo>Branch: ${env.CIRCLE_BRANCH}</echo>
		<property file="build.${env.CIRCLE_BRANCH}.properties" />
		<echo>${build.cmd}</echo>
		<antcall target="${build.cmd}" />
	</target>
	
	<!--
		Tests that the deployment of meta-data to the target org will succeed
		but does not *save* the meta-data. This is just for validating that the
		deployment would succeed.
	-->
	<target name="DeployAndCheckOnly">
		<echo>Deploy Code CheckOnly in Org with username: ${sf.username}</echo>
		<sf:deploy 
			username="${sf.username}" 
			password="${sf.password}" 
			serverurl="${sf.serverurl}" 
			maxPoll="${sf.maxPoll}" 
			deployRoot="${user.dir}/src" 
			logType="${env.SF_LOGDETAIL}" 
			checkOnly="${sf.checkOnly}" />
	</target>
	
	<!--
		Deploys the meta-data to the target org and then runs all unit tests. If
		any unit tests fail, a roll-back will occurr and nothing will have changed.
	-->
	<target name="DeployAndRunAllTests">
		<echo>Deploy and RunAllTests in Org with username: ${sf.username}</echo>
		<sf:deploy 
			username="${sf.username}" 
			password="${sf.password}" 
			serverurl="${sf.serverurl}" 
			maxPoll="${sf.maxPoll}" 
			deployRoot="${user.dir}/src" 
			logType="${env.SF_LOGDETAIL}"
			runallTests="${sf.runallTests}" />
	</target>
	
	<!--
		Deploys the meta-data to the target org and then runs all unit tests. If
		any unit tests fail, a roll-back will occurr and nothing will have changed.
	-->
	<target name="DeployWithoutTests">
		<echo>Deploy without running tests in Org with username: ${sf.username}</echo>
		<sf:deploy 
			username="${sf.username}" 
			password="${sf.password}" 
			serverurl="${sf.serverurl}" 
			maxPoll="${sf.maxPoll}" 
			deployRoot="${user.dir}/src" 
			logType="${env.SF_LOGDETAIL}"
			runallTests="false" />
	</target>

	<!--
		Performs a full deploy to the target org and destroys any stale meta-data in the
		target org that's not in the Git Repo, and then runs tests.
	-->
	<target name="DeployAndDestroyStale">
		<echo>Deploy and Destroy Stale in Org with username: ${sf.username}</echo>
		
		<!-- Attempt to destroy any stale metadata but continue even if this fails -->
		<trycatch>
			<try>
				<antcall target="destroyStaleMetadata" />
			</try>
			<catch>
				<echo>First run of destroyStaleMetadata failed.  Ignoring for now but it may cause build failures in other targets.</echo>
			</catch>
		</trycatch>

		<!-- Deploy src directory -->
		<antcall target="DeployWithoutTests" />

		<!-- Delete any metadata from the org which is not in the repo -->
		<antcall target="destroyStaleMetadata" />

		<!-- Run all Tests -->
		<antcall target="DeployAndRunAllTests" />
	</target>
	
	<!--
		Retrieves meta-data for the named packaged from the target org.
	-->
	<target name="RetrievePackagedToSrc">
		<property environment="env" />
		<property file="build.properties" />
		<echo>Retrieve a package from salesforce to your local src folder. An alternate to Mavens/Eclipse "Refresh from server..."</echo>
		<echo>User: ${sf.username}</echo>
		<echo>Package: ${sf.package.name}</echo>
		<sf:retrieve 
			username="${sf.username}" 
			password="${sf.password}" 
			serverurl="${sf.serverurl}" 
			retrieveTarget="src" 
			packageNames="${sf.package.name}"/>
	</target>

	<!-- 
		There's really no point in running this in CircleCI unless we can do something with the output
	-->
	<target name="SfApexDoc">
		<java fork="true" jar="${user.dir}/lib/SfApexDoc.jar" failonerror="true">
			<arg line="-d -s ${user.dir}/src/classes -t ${user.dir}/docs -a ${user.dir}/SfApexDocAuthor.txt -h ${user.dir}/SfApexDocHome.txt" />
		</java>
	</target>
	
	<target name="buildPackageXmlAndDeployWithTests">
		<antcall target="updatePackageXml" />
		<antcall target="DeployAndRunAllTests" />
		<antcall target="destroyStaleMetadata" />
		
		<copy file="../src/package.xml" todir="${env.CIRCLE_ARTIFACTS}"/>
		
	</target>



	<!--
		U T I L I T Y   T A R G E T S   &   M A C R O S
		Borrowed from CumulusCI
	-->
	
	<!-- updatePackageXml: Builds a new package.xml based upon the metadata in the src directory -->
    <target name="updatePackageXml">
        <buildPackageXml package="${sf.package.name}" version="${sf.apiVersion}" srcDir="../src"/>
    </target>

	<!--
		Destroys all meta-data in the target org that is not in the git repo.
	-->
	<target name="destroyStaleMetadata">
		<echo>----------------------------------------------------------------------------</echo>
		<delete dir="uninstallsrc" />
		<delete dir="uninstall" />

		<!-- Fetch all metadata in the  package from target org -->
		<mkdir dir="uninstallsrc"/>
		<sf:retrieve 
			username="${sf.username}" 
			password="${sf.password}" 
			serverurl="${sf.serverurl}" 
			retrieveTarget="uninstallsrc" 
			packageNames="${sf.package.name}"/>

		<!-- Build a destructiveChanges.xml pacckage to delete metadata in org but not in repo -->
		<buildDestroyStaleMetadata srcdir="uninstallsrc" commdir="../src" dir="uninstall" />
		
		<copy file="${user.dir}/build/uninstall/destructiveChanges.xml" todir="${env.CIRCLE_ARTIFACTS}"/>
		
		<!-- deploy the destructiveChanges.xml package -->
		<sf:deploy 
			username="${sf.username}" 
			password="${sf.password}" 
			serverurl="${sf.serverurl}" 
			deployRoot="uninstall" 
			runAllTests="false" 
			logType="${env.SF_LOGDETAIL}"
			purgeOnDelete="true" />

		<delete dir="uninstallsrc" />
		<delete dir="uninstall" />
	</target>

	<macrodef name="buildDestroyStaleMetadata" description="Constructs a destructiveChanges.xml which deletes any metadata from one directory which does not exist in another">
		<attribute name="srcdir" description="Source directory, usually containing metadata from target org fetched via retrievePackaged" />
		<attribute name="commdir" description="The directory whose metadata should be compared to srcdir.  Any metadata not in this directory's package.xml but in srcdir's package.xml will be added to destructiveChanges.xml" />
		<attribute name="dir" description="Target directory to create the destructiveChanges.xml package" />
		<sequential>
		  <!-- Run xslt against package.xml files to generate a text file containing TYPE::MEMBER lines for each member for easier comparison later -->
		  <xslt in="@{srcdir}/package.xml" out="@{srcdir}/package.xml.members" style="${user.dir}/build/xsl/diff_package_xml.xsl" />
		  <xslt in="@{commdir}/package.xml" out="@{commdir}/package.xml.members" style="${user.dir}/build/xsl/diff_package_xml.xsl" />
		  <loadfile property="src.package.xml.members" srcfile="@{srcdir}/package.xml.members" />
		  <loadfile property="comm.package.xml.members" srcfile="@{commdir}/package.xml.members" />

		  <delete dir="@{dir}" />
		  <mkdir dir="@{dir}" />

		  <!-- Create the package.xml to accompany the destructiveChanges.xml -->
		  <echo file="@{dir}/package.xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
	<Package xmlns="http://soap.sforce.com/2006/04/metadata">
	<version>${sf.apiVersion}</version>
	</Package>]]></echo>

		  <!-- initialize the destructiveChanges.xml file -->
		  <echo file="@{dir}/destructiveChanges.xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;${line.separator}</echo>
		  <echo file="@{dir}/destructiveChanges.xml" append="true">&lt;Package xmlns="http://soap.sforce.com/2006/04/metadata"&gt;${line.separator}</echo>

		  <var name="dest.types.xml" value="" />
		  <var name="prev.type" value="" />

		  <for delimiter="${line.separator}" list="${src.package.xml.members}" param="line" trim="true">
			<sequential>
			  <if>
				<!-- Only process lines which contain ::, the delimiter added by the xslt template between type and member name -->
				<contains string="@{line}" substring="::" />
				<then>
				  <if>
					<and>
					  <not><contains string="${comm.package.xml.members}" substring="@{line}" /></not>
					  <!-- Skip CustomLabels since individual custom labels are deleted via CustomLabel -->
					  <not><contains string="@{line}" substring="CustomLabels::" /></not>
					</and>
					<then>
					  <!-- Parse type and member name from string in format TYPE::MEMBERNAME -->
					  <propertyregex property="line.type" override="true" input="@{line}" regexp="(.*)\::(.*)" replace="\1" />
					  <propertyregex property="line.member" override="true" input="@{line}" regexp="(.*)\::(.*)" replace="\2" />
					  <if>
						<not><equals arg1="${prev.type}" arg2="" /></not>
						<then>
						  <if>
							<not><equals arg1="${prev.type}" arg2="${line.type}" /></not>
							<then>
							  <var name="dest.types.xml" value="${dest.types.xml}    &lt;name>${prev.type}&lt;/name>${line.separator}  &lt;/types>${line.separator}  &lt;types>${line.separator}" />
							  <var name="prev.type" value="${line.type}" />
							</then>
							<else>
							</else>
						  </if>
						</then>
						<else>
						  <var name="dest.types.xml" value="${dest.types.xml}  &lt;types>${line.separator}" />
						  <var name="prev.type" value="${line.type}" />
						</else>
					  </if>
					  <var name="dest.types.xml" value="${dest.types.xml}    &lt;members>${line.member}&lt;/members>${line.separator}" />
					</then>
				  </if>
				</then>
			  </if>
			</sequential>
		  </for>
		  <if>
			<not><equals arg1="${prev.type}" arg2="" /></not>
			<then>
			  <var name="dest.types.xml" value="${dest.types.xml}    &lt;name>${line.type}&lt;/name>${line.separator}  &lt;/types>${line.separator}" />
			</then>
		  </if>

		  <!-- Finalize the destructiveChanges.xml file -->
		  <echo file="@{dir}/destructiveChanges.xml" append="true">${dest.types.xml}</echo>
		  <echo file="@{dir}/destructiveChanges.xml" append="true">  &lt;version&gt;${sf.apiVersion}&lt;/version&gt;${line.separator}</echo>
		  <echo file="@{dir}/destructiveChanges.xml" append="true">&lt;/Package&gt;</echo>

		  <!-- clean up -->
		  <delete file="@{srcdir}/package.xml.members" />
		  <delete file="@{commdir}/package.xml.members" />
		</sequential>
	</macrodef>

</project>
